#pragma once
{%- set snapshot = snapshots[snapshot_name] %}

#include "public.h"
{% for include in snapshot.cpp_includes %}
#include <{{ include }}>
{% endfor %}
#include <yt/yt/orm/library/snapshot/includes_for_generated_objects.h>

{% if snapshot.cpp_namespace -%}
namespace {{ snapshot.cpp_namespace }} {
{%- endif %}

////////////////////////////////////////////////////////////////////////////////

{%- for object in snapshot.objects %}

class {{ object.cpp_key_type }}
{
public:
    {{ "explicit " if (object.key_fields | length) == 1 else "" }}{{ object.cpp_key_type }}(
        {%- for field in object.key_fields %}
        {{ field.cpp_type }} {{ field.lower_camel_case_name }}{% if not loop.last %},{% endif %}
        {%- endfor %});

    static {{ object.cpp_key_type }} Parse(::NYT::NOrm::NClient::NNative::TPayload payload);
    static {{ object.cpp_key_type }} Parse(
        std::vector<::NYT::NOrm::NClient::NNative::TPayload> payloads);
    {% for field in object.key_fields %}
    ::NYT::NOrm::NSnapshot::TObjectFieldGetterReturn<{{ field.cpp_type }}> {{ field.camel_case_name }}() const;
    {%- endfor %}

    ::NYT::NOrm::NClient::NObjects::TObjectKey ToObjectKey() const;

    friend bool operator==(const {{ object.cpp_key_type }}& lhs, const {{ object.cpp_key_type }}& rhs);
    friend std::strong_ordering operator<=>(const {{ object.cpp_key_type }}& lhs, const {{ object.cpp_key_type }}& rhs);

    friend void FormatValue(::NYT::TStringBuilderBase* builder, const {{ object.cpp_key_type }}& key, TStringBuf spec);

private:
    {%- for field in object.key_fields %}
    {{ field.cpp_type }} {{ field.camel_case_name }}_;
    {%- endfor %}
};

{%- endfor %}

////////////////////////////////////////////////////////////////////////////////

{%- for object in snapshot.objects %}

class {{ object.cpp_data_type }}
    : public ::NYT::TRefCounted
{
public:
    using TKey = {{ object.cpp_key_type }};

    {{ "explicit " if (object.all_fields | length) == 1 else "" }}{{ object.cpp_data_type }}(
        {%- for field in object.all_fields %}
        {{ field.cpp_type }} {{ field.lower_camel_case_name }}{% if not loop.last %},{% endif %}
        {%- endfor %});

    static ::NYT::TIntrusivePtr<{{ object.cpp_data_type }}> Parse(
        std::vector<::NYT::NOrm::NClient::NNative::TPayload> payloads);
    {% for field in object.all_fields %}
    ::NYT::NOrm::NSnapshot::TObjectFieldGetterReturn<{{ field.cpp_type }}> {{ field.camel_case_name }}() const;
    {%- endfor %}

    {{ object.cpp_key_type }} Key() const;
    {%- for reference in object.many_to_one_references %}
    {{ reference.cpp_key_getter_return_type }} {{ reference.camel_case_name }}Key() const;
    {%- endfor %}

private:
    {%- for field in object.all_fields %}
    {{ field.cpp_type }} {{ field.camel_case_name }}_;
    {%- endfor %}
};

DECLARE_REFCOUNTED_CLASS({{ object.cpp_data_type }});
DEFINE_REFCOUNTED_TYPE({{ object.cpp_data_type }});

{%- endfor %}

{%- if snapshot.has_one_to_many_references %}

////////////////////////////////////////////////////////////////////////////////

{%- for object, reference in snapshot.one_to_many_references %}

struct T{{ object.camel_case_name }}{{ reference.camel_case_name }}Reference
{
    using TOneObjectData = {{ object.cpp_data_type }};
    using TManyObjectData = {{ reference.remote_object.cpp_data_type }};
    static constexpr auto KeyGetter = &TManyObjectData::{{ reference.remote_many_to_one_reference.camel_case_name }}Key;
};

{%- endfor %}

{%- endif %}

////////////////////////////////////////////////////////////////////////////////

struct TSnapshotDataDescription
{
    using TObjectDataTypes = ::NYT::NOrm::NMpl::TTypes<
        {%- for object in snapshot.objects %}
        {{ object.cpp_data_type }}{% if not loop.last %},{% endif %}
        {%- endfor %}>;

    using TOneToManyReferenceTypes = ::NYT::NOrm::NMpl::TTypes<
        {%- for object, reference in snapshot.one_to_many_references %}
        T{{ object.camel_case_name }}{{ reference.camel_case_name }}Reference{% if not loop.last %},{% endif %}
        {%- endfor %}>;
};

using TSnapshotDataPtr =
    ::NYT::NOrm::NSnapshot::TSnapshotDataPtr<TSnapshotDataDescription>;

////////////////////////////////////////////////////////////////////////////////

{%- for object in snapshot.objects %}

class {{ object.cpp_type }}
{
public:
    using TKey = {{ object.cpp_key_type }};
    using TData = {{ object.cpp_data_type }};

    static constexpr ::NYT::NOrm::NSnapshot::TObjectDescription Description = {
        .HumanReadableName = "{{ object.human_readable_name }}",
        .SnakeCaseName = "{{ object.snake_case_name }}",
        .CamelCaseName = "{{ object.camel_case_name }}",

        .TypeValue = {{ object.type_value }},
    };

    static const ::NYT::NOrm::NSnapshot::TObjectAttributeDescription AttributeDescription;

    {{ object.cpp_type }}({{ object.cpp_data_ptr_type }} objectData, TSnapshotDataPtr snapshotData);
    {% for field in object.all_fields %}
    ::NYT::NOrm::NSnapshot::TObjectFieldGetterReturn<{{ field.cpp_type }}> {{ field.camel_case_name }}() const;
    {%- endfor %}

    {{ object.cpp_key_type }} Key() const;
    {%- for reference in object.many_to_one_references %}
    {{ reference.cpp_key_getter_return_type }} {{ reference.camel_case_name }}Key() const;
    {%- endfor %}
    {%- for reference in object.many_to_one_references %}
    auto {{ reference.camel_case_name }}() const;
    {%- endfor %}
    {%- for reference in object.one_to_many_references %}
    auto {{ reference.camel_case_name }}() const;
    {%- endfor %}

private:
    {{ object.cpp_data_ptr_type }} ObjectData_;
    TSnapshotDataPtr SnapshotData_;
};

{%- endfor %}

////////////////////////////////////////////////////////////////////////////////

struct TSnapshotDescription
{
    using TDataDescription = TSnapshotDataDescription;

    using TObjectTypes = ::NYT::NOrm::NMpl::TTypes<
        {%- for object in snapshot.objects %}
        {{ object.cpp_type }}{% if not loop.last %},{% endif %}
        {%- endfor %}>;
};

////////////////////////////////////////////////////////////////////////////////

{% if snapshot.cpp_namespace -%}
} // namespace {{ snapshot.cpp_namespace }}
{%- endif %}

{%- for object in snapshot.objects %}

template <>
struct THash<{{ snapshot.cpp_namespace }}::{{ object.cpp_key_type }}>
{
    size_t operator()(const {{ snapshot.cpp_namespace }}::{{ object.cpp_key_type }}& key) const;
};

{%- endfor %}

////////////////////////////////////////////////////////////////////////////////

#define OBJECTS_INL_H_
#include "objects-inl.h"
#undef OBJECTS_INL_H_
